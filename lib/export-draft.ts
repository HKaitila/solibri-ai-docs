// lib/export-draft.ts
/**
 * Generate exportable draft article updates in multiple formats
 * For individual article drafts (not full analysis export)
 */

export async function generateExportableDraft(
  articleTitle: string,
  suggestion: string,
  draftUpdate: string,
  articleUrl: string,
  releaseVersion: string
): Promise<{ markdown: string; xml: string; json: string }> {
  const timestamp = new Date().toISOString().split('T')[0];

  // MARKDOWN FORMAT
  const markdown = `# Draft Update: ${articleTitle}

**Release Version:** ${releaseVersion}
**Generated:** ${timestamp}
**Article URL:** ${articleUrl}

---

## Summary of Changes

${suggestion}

---

## Proposed Content

${draftUpdate}

---

## Next Steps

1. Review the proposed content above
2. Copy relevant sections into your Paligo article
3. Adapt language and formatting as needed to match your documentation style
4. Update any cross-references or related articles
5. Publish and verify

---

*This draft was auto-generated by Release Notes Analyzer. Manual review recommended before publishing.*
`;

  // XML FORMAT (Paligo-friendly)
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
  <title>Draft Update: ${escapeXml(articleTitle)}</title>
  <para>
    <emphasis role="strong">Release Version:</emphasis> ${escapeXml(releaseVersion)}
  </para>
  <para>
    <emphasis role="strong">Generated:</emphasis> ${timestamp}
  </para>
  <para>
    <emphasis role="strong">Article URL:</emphasis> <link xlink:href="${escapeXml(articleUrl)}">${escapeXml(articleUrl)}</link>
  </para>
  <section>
    <title>Summary of Changes</title>
    <para>${escapeXml(suggestion)}</para>
  </section>
  <section>
    <title>Proposed Content</title>
    ${convertMarkdownToXmlSections(draftUpdate)}
  </section>
  <section>
    <title>Next Steps</title>
    <orderedlist>
      <listitem><para>Review the proposed content above</para></listitem>
      <listitem><para>Copy relevant sections into your Paligo article</para></listitem>
      <listitem><para>Adapt language and formatting as needed</para></listitem>
      <listitem><para>Update cross-references if needed</para></listitem>
      <listitem><para>Publish and verify</para></listitem>
    </orderedlist>
  </section>
</section>`;

  // JSON FORMAT
  const json = JSON.stringify({
    metadata: {
      type: 'draft-article-update',
      articleTitle,
      releaseVersion,
      generated: timestamp,
      articleUrl
    },
    content: {
      summary: suggestion,
      proposedDraft: draftUpdate
    },
    instructions: [
      'Review the proposed content above',
      'Copy relevant sections into your Paligo article',
      'Adapt language and formatting as needed',
      'Update cross-references if needed',
      'Publish and verify'
    ]
  }, null, 2);

  return { markdown, xml, json };
}

/**
 * Convert markdown-style sections to XML section elements
 */
function convertMarkdownToXmlSections(content: string): string {
  const lines = content.split('\n');
  const sections: string[] = [];

  let currentSection = '';
  let inCodeBlock = false;

  for (const line of lines) {
    if (line.startsWith('```')) {
      inCodeBlock = !inCodeBlock;
      continue;
    }

    if (inCodeBlock) {
      if (line.trim()) {
        sections.push(`<programlisting>${escapeXml(line)}</programlisting>`);
      }
    } else if (line.startsWith('# ')) {
      if (currentSection) sections.push(currentSection);
      const title = line.replace(/^# /, '').trim();
      currentSection = `<section><title>${escapeXml(title)}</title>`;
    } else if (line.startsWith('## ')) {
      const subtitle = line.replace(/^## /, '').trim();
      sections.push(`<subtitle>${escapeXml(subtitle)}</subtitle>`);
    } else if (line.startsWith('- ')) {
      const item = line.replace(/^- /, '').trim();
      sections.push(`<itemizedlist><listitem><para>${escapeXml(item)}</para></listitem></itemizedlist>`);
    } else if (line.trim()) {
      sections.push(`<para>${escapeXml(line)}</para>`);
    }
  }

  if (currentSection) {
    sections.push(currentSection + '</section>');
  }

  return sections.join('\n    ');
}

/**
 * Escape XML special characters
 */
function escapeXml(str: string): string {
  if (!str) return '';
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}